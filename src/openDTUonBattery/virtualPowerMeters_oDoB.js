// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


/**
*
* Virtual powermeter for open DTU on Battery (oDoB)
*
* This scripts runs on any shelly with api 2 or greater.
* This script reads in the current power comsuption and 
* divides it up between n virtual powermeter. The powermeter 
* are then used to feed an controller of oDoB.
* The multiple controller will be cascaded so that at each 
* point in time only one controller is working and the others 
* are independently either at their configured minimum power delivery
* or at their maximum power delivery. 
*
* With this all said, it is noteworthy, that all controllers 
* are connected to the same DC power supply system 
* ( solarpanels and batteries).
*
**/

// version 0.1


// set script ID here
let scriptId=3;
 
// configuration for each controller, add as many as you have controller ( there is an upper limit off 5 controllers defined by the
//  shelly, because you can only be registered up to 5 HTTP endpoints (at the time of writing this code)
// the order in which the controller are added reflects the cascade order, first controller added is the first 
// in the cascade, the later are following then
// nominalPower_Watt : the maximum power the controller can provide
// minRequiredPower_Watt: the minimum Power required to run the controller/inverter,
// controllerIp: the ip of the odob controller ( inverter needs to be the first/only one registered (e.g.: position 0) at the given controller)
let configs=[
  		{ nominalPower_Watt: 100, minRequiredPower_Watt: 50, controllerIp: '192.168.178.67'}
	, 	{ nominalPower_Watt: 800, minRequiredPower_Watt: 80, controllerIp: '192.168.178.68'}
];

//power measuring device
	// choose between "local" e.g. this script is running on a gen2 device which can measure net power ( nothing else needs to be configured for the powerreading)
	// or "http" e.g. pulls the power readings by http requests ( configure http settings in httpConfig underneath)
	// or "mqtt" get the power readings delivered by mqtt topic ( configure mqtt settings in mqttConfig underneath)
let netPowerConfig = "http" // choose one off "local", "mqtt" or "http"

// configure mqtt access ( path to the power reading)
let mqttConfig = { topic: "solar/dtuOnBattery/ac/power" } // the topic of the powerreading required for mqtt

// configure http access ( path to the power reading)
let httpConfig = {
		 address: "http://192.168.178.67/api/livedata/status" // the address of the http powerreading required
		, jsonPath: "inverters.0.AC.0.Power.v" // jsonPath for parsing the message for the powerreading, seperate every field by a dot
		// e.g.: inverters[0].name needs to be represented as: inverters.0.name
	};

	
// Configuration of your oDoB contorller i ( on position i) in the configs variable (see above) (i=1..n)
//
// define in Powermeter the mode https + Json and use http://<Shelly ip this script runs on>/script/<scriptId>/pwr<i> 
// e.g. assume the ip of the shelly on which this script runs on to be: 1.2.3.4, 
// the script id of this script to be 7 and you want to configure the 2nd  odob controller
// then use:  http://1.2.3.4/script/7/pwr2
// the Json path is always pwr


// -------------------------------------------------- configure above this line, don't touch anything underneath this line !!! -------------------------------------------

// the last power reading off each controller
let previousPower = [];

// the defined start power of each controller
let startPower = [];

// power brought to you by the grid
let netPower = 0;

//power generated by all the controllers/inverters
let generatedPower = 0;

// initialize the previous step power for each controller,
// register to mqtt topics 
// create http endpoints
// and configure power readings
function initialize(){  
	var cumulatedPower =0;
	//distribute callbacks by timer to distribute cpu load
	nrHttpRequest = configs.length;
	if ( "http" == netPowerConfig.toLowerCase()){
		nrHttpRequest = nrHttpRequest + 1;
	}
	// configure virtualPowerMeter readings
	for (var i = 0; i < configs.length; i++) {
		startPower[i] = cumulatedPower;
		cumulatedPower = cumulatedPower + configs[i].nominalPower_Watt;
		previousPower[i] =0;
		if (configs[i].mqttControllerBasicTopic.substr(-1) != '/') configs[i].mqttControllerBasicTopic += '/';
		// wait until it is time to start the timer. To distribute cpu load during callbacks // is this useful at all??? 
		sleep( i*2500/nrHttpRequest);
		// call twice during a normal hoymiles cycle (5 seconds)
		dict = {url: "http://" + configs[i].controllerIp + "/api/livedata/status", index: i}
		Timer.set( 2500, true, controllerTimer, dict);
		HTTPServer.registerEndpoint( "pwr" + (i+1) , VirtualPowerMeterReadings, i)
	}
	// configure netPower readings
	switch (netPowerConfig.toLowerCase()){
		case 'local':
			Shelly.addStatusHandler( 
				function(event, userdata){
					// Runs when a new Power reading is comming in
					if (typeof event.delta.total_act_power !== "undefined") {
						netPower = event.delta.total_act_power;
					}
				}
				, null);
			break;
		case 'mqtt':
			MQTT.subscribe(mqttConfig.topic, UpdateNetPowerMQTT);
			break;
		case 'http':
			sleep( configs.length * 2500 / nrHttpRequest);
			// calls repeatedly, the httpTimer function
			Timer.set( 2500, true, powerMeterTimer);
			httpConfig.jsonPath = httpConfig.jsonPath.split(".");
			break;
	}
}

// cyclicly update the net power when http is configured
function powerMeterTimer( userdata){
	Shelly.call("HTTP.GET", {url: httpConfig.address}, processHttpResponseForNetPower);
}

// cyclicly update the inverter power when http is configured
function controlerTimer( dict){
	Shelly.call("HTTP.GET", {url: dict.url}, processHttpResponseForInverterPower, dict.index);
	
//  Shelly.call("HTTP.GET", {"url": "http://192.168.178.67/api/livedata/status/"}, 
//    function (res, error_code, error_msg, userdata){
//            print(res);
//            print(error_code);
//            print(error_msg);
//            print(userdata);
//        },
//        1);	
	
}


// process the http Response of the power Meter configured with http polling
function processHttpResponseForNetPower( result, error_code, error) {
	if (error_code != 0) {
		// something went wrong ... what shall we do?? ( with a drunken sailor?)
		print("HttpRequest to powerMeter Failed with error code: ");
		print(error_code);
		print("\nand Error: ")
		print(error);
	} else {
		body = JSON.parse(result.body);
		// dynamically parse the unknown body from a split up string
		for(i=0; i < httpConfig.jsonPath.length; i++){
			body = body[httpConfig.jsonPath[i]];
		}
		netPower = body;
		print("NetPower: " + netPower);
	}
}

// process the http Response of the power Meter configured with http polling
function processHttpResponseForInverterPower( result, error_code, error, index) {
	if (error_code != 0) {
		// something went wrong ... what shall we do?? ( with a drunken sailor?)
		print("HttpRequest to controller Failed with error code: ");
		print(error_code);
		print("\nand Error: ")
		print(error);
	} else {
		body = JSON.parse(result.body);
		newPower = body.inverters[0].AC[0].Power.v;
		UpdateControllerPower( newPower, index);
	}
}

// update the netPower from mqtt message
function UpdateNetPowerMQTT( topic, message){
	netPower = message;
}

// send the virtual power meter reading to the requester
function VirtualPowerMeterReadings( request, response, index){
//    print(index);
	var virtualPowerMeter = calculateVirtualPowerReadings( index);
//  print("VPM: " + virtualPowerMeter);
	response.body = JSON.stringify( { PWR : virtualPowerMeter } );
	response.code = 200;
	response.send();
}

// recieve new controller Power values 
function UpdateControllerPower( newPower, index){
	generatedPower = generatedPower - previousPower[index] + newPower;
//	print("GenPower: " + generatedPower);
	previousPower[index] = newPower;
	print("GeneratedPower: " + generatedPower + " NewPower: " + newPower);
}

// calculate the power which is seen by the virtual power meter of index
// virtualPowerMeter = measured net-power - required StartPower + over all produced power off all other contorllers
function calculateVirtualPowerReadings( index){
	var powerOffAllOtherInverters = generatedPower - previousPower[index];
//	print([generatedPower, previousPower[index]])
	var virtualPowerMeter = netPower + powerOffAllOtherInverters - startPower[index];
//  limiting the power so that at least each controller recieves its minimum power configured
	var limitedPowerMeter = Math.max( configs[index].minRequiredPower_Watt - previousPower[index], virtualPowerMeter);
//	print("Index: " + index);
//	print("Netpower: " + netpower);
//	print("VirtualPowerMeter: " + virtualPowerMeter)
//	print("limitedPowerMeter: " + limitedPowerMeter)
	return limitedPowerMeter;
}

initialize();